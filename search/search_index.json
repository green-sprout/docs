{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Documentation","text":"<p> This is the Documentation of the Project of the Green Sprout Team</p>"},{"location":"docs/general/Refactoring/","title":"Refactoring","text":""},{"location":"docs/general/Refactoring/#refactoring-zusammenfassung","title":"Refactoring-Zusammenfassung","text":""},{"location":"docs/general/Refactoring/#osmservice","title":"\ud83d\udee0\ufe0f OsmService","text":"<ul> <li><code>@Service</code> und <code>@Slf4j</code> Annotationen hinzugef\u00fcgt f\u00fcr klare Struktur und Logging.</li> <li><code>ObjectMapper</code> \u00fcber Konstruktor injiziert (bessere Testbarkeit und Konfiguration).</li> <li>Wiederverwendbaren HTTP-Client eingef\u00fchrt zur effizienten Ressourcennutzung.</li> <li>Verbesserte Fehlerbehandlung durch sauberes Exception Handling.</li> <li>Fehler werden nun korrekt geloggt statt \u00fcber <code>System.out</code> ausgegeben.</li> </ul>"},{"location":"docs/general/Refactoring/#osmcontroller","title":"\ud83e\udde9 OsmController","text":"<ul> <li>Konstruktor-Injektion mit <code>@RequiredArgsConstructor</code> eingef\u00fchrt.</li> <li>Verwendung von <code>@RestController</code> statt <code>@Controller</code> + <code>@ResponseBody</code>.</li> <li><code>System.out.println</code> durch <code>slf4j</code> Logging ersetzt.</li> <li>Verbesserte und konsistentere Fehlermeldungen f\u00fcr bessere Nutzererfahrung.</li> </ul>"},{"location":"docs/general/Refactoring/#spateres-refactoring","title":"\ud83d\udd10 Sp\u00e4teres Refactoring","text":"<ul> <li>JWT-Secret-Key abgesichert (nicht mehr im Code hardcoded).</li> <li>Zus\u00e4tzliche Tests geschrieben, um neue Klassen und Funktionalit\u00e4t abzudecken.</li> </ul>"},{"location":"docs/general/Review/","title":"Technical Review","text":"<p>Datum: 27.05.25</p> <p>Dauer: 8:32 / 9:17 </p> <p>Teilnehmer Moderation: Safae K./Samuel B.</p> <p>Notizen: Samuel B.</p> <p>Code Review (Team Intern): Safae K./Jonas S./Valentin W./Paula K./Samuel B.</p> <p>Code Review (Extern): Lukas S. (Team Restaurant Reservierung)</p> <p>Projektmanagement Review: Safae K./Samuel B.</p> <p>Ziel / Fokus</p> <ul> <li> <p>Ausgew\u00e4hlte Abschnitte:      Backend, generell</p> </li> <li> <p>Was wird untersucht?     Sicherheit + Generelle \u00dcbersicht</p> </li> <li> <p>Warum die Wahl?     Die Wahl fiel auf das Backend, da wir hier ein h\u00f6heres Niveau im Rahmen der Review aufbringen konnten und auch unser externer Review-Partner sich besser mit dem Thema auskennt.</p> </li> </ul> <p>Komponenten f\u00fcr die Review - Login/Registierung Komponente - OpenStreetAPI Daten Aurufen Komponente - Unit Tests - Datenbankverbindung - Allgemeine Struktur</p> <p>Kriterien f\u00fcr die Review - Codequalit\u00e4t - Security - Fehlerbehandlung</p> <p>Review Methodik</p> <p>Walkthrough + Code Review</p> <p>Ergebnis - Codequalit\u00e4t:     - zumeist hohe Codequalit\u00e4t.     - Kernelmente des Systems werden getestet. - Security:     - <code>CorsConfig.java</code> - anyRequest().permitAll()     - <code>JWTService.java</code> - Secret Key sollte ausgelagert werden. - Fehlerbehandlung:     - <code>AuthService.java</code>, <code>OsmController.java</code> weisen eine umfangreiche Fehlerbehandlung auf</p>"},{"location":"docs/general/Review/#external-review","title":"External Review","text":"<p>Komponenten f\u00fcr die Review - Login/Registierung Komponente  - OpenStreetAPI Daten Aurufen Komponente - Unit Tests - Datenbankverbindung - Allgemeine Struktur</p> <p>Kriterien f\u00fcr die Review - Codequalit\u00e4t - Security - Fehlerbehandlung</p> <p>Review Methodik</p> <p>Walkthrough + Code Review</p> <p>Ergebnis - Codequalit\u00e4t:     - Performancerelevante Quellcodesegmente weisen eine durchgehend hohe Codequalit\u00e4t aus.     - Tests decken sicherheitsrelevante Kernkomponenten der Anwendung ausreichend ab. - Security:     - <code>SecurityConfig.java</code> - CORS-Sicherheitsstandards m\u00fcssen einhalten werden (.permitAll()-Methode)     - <code>CorsConfig.java</code> - keine beliebigen Headers und any-Origins akzeptieren     - <code>AuthService.java</code> - Implementieren von Input-Sanitisation-Mechanismen f\u00fcr benutzerspezifische Daten.     - <code>JWTService.java</code> - Datei enth\u00e4lt Authentifizierungsschl\u00fcssel, welcher NICHT in der Datei stehen sollte. - Fehlerbehandlung:     - <code>AuthController.java</code> - hat kein Error-Handling     - ansonsten weitreichendes Error Handling</p> <p>Bemerkung</p> <p><code>Sicherheitstechnisch ist vielleicht noch etwas Bedarf da, das man da noch ein paar Sachen fixt. Ansonsten solide Projektstruktur.</code></p>"},{"location":"docs/general/UCRS_FilterMap/","title":"Use-Case-Realization Specification: Filter Map","text":"<p>Version 1.0</p>"},{"location":"docs/general/UCRS_FilterMap/#revision-history","title":"Revision History","text":"Date Version Description Author 27.10.2024 1.0 UCRS for the Filter Map use case Green Sprout Team"},{"location":"docs/general/UCRS_FilterMap/#1-introduction","title":"1. Introduction","text":""},{"location":"docs/general/UCRS_FilterMap/#11-purpose","title":"1.1 Purpose","text":"<p>The purpose of this Use-Case Realization Specification is to detail the design of the \u201cFilter Map\u201d use case, where a user selects filter criteria on an interactive map, which then displays points of interest that correspond to the filtered properties.</p>"},{"location":"docs/general/UCRS_FilterMap/#12-scope","title":"1.2 Scope","text":"<p>This document covers the interaction flow between the User, Front-End, Back-End, and OpenStreetMap API for filtering and displaying points of interest based on user-selected criteria.</p>"},{"location":"docs/general/UCRS_FilterMap/#13-definitions-acronyms-and-abbreviations","title":"1.3 Definitions, Acronyms, and Abbreviations","text":"<ul> <li>POI: Point of Interest</li> <li>API: Application Programming Interface</li> <li>n/a: not applicable</li> <li>UCRS : Use-Case-Realization Specification</li> </ul>"},{"location":"docs/general/UCRS_FilterMap/#14-references","title":"1.4 References","text":"<p>n/a</p>"},{"location":"docs/general/UCRS_FilterMap/#15-overview","title":"1.5 Overview","text":"<p>This document is organized into sections detailing the purpose, scope, and flow of events in this use case, followed by derived requirements for implementation.</p>"},{"location":"docs/general/UCRS_FilterMap/#2-flow-of-eventsdesign","title":"2. Flow of Events\u2014Design","text":"<p>The following describes the flow of events in the \"Filter Map\" use case. The sequence diagram is shown below for visual reference:</p> <p></p> <p>Flow Steps: - User Action: The user selects filter keys on the front-end interface to define specific types of points of interest to display on the map. - Front-End Request: The front-end sends a \"request new map\" message to the back end, including the user-selected filter keys. - Back-End to OpenStreetMap API: The back end processes the request and sends a \"request new points of interest\" message to the OpenStreetMap API. This request includes the filter parameters specified by the user. - API Response: The OpenStreetMap API returns data containing the filtered points of interest matching the criteria. - Back-End to Front-End: The back end forwards the received data to the front-end as a \"map\" response. - Map Display: The front-end processes and displays the updated map with the filtered points of interest for the user.</p>"},{"location":"docs/general/UCRS_FilterMap/#3-derived-requirements","title":"3. Derived Requirements","text":"<ol> <li>Real-Time Data: The system should update the map in real-time based on the user's selected filters.</li> <li>Error Handling: If the OpenStreetMap API fails to respond or encounters an error, the system should notify the user and allow them to retry.</li> <li>Scalability: The back end must efficiently handle multiple requests to the OpenStreetMap API without performance degradation.</li> <li>Data Accuracy: The displayed points of interest must accurately reflect the filter criteria selected by the user.</li> </ol>"},{"location":"docs/general/UCRS_ViewRestaurant/","title":"Use-Case-Realization Specification: View Restaurant","text":"<p>Version 1.0</p>"},{"location":"docs/general/UCRS_ViewRestaurant/#revision-history","title":"Revision History","text":"Date Version Description Author 28.10.2024 1.0 UCRS for the Filter Map use case Green Sprout Team"},{"location":"docs/general/UCRS_ViewRestaurant/#1-introduction","title":"1. Introduction","text":""},{"location":"docs/general/UCRS_ViewRestaurant/#11-purpose","title":"1.1 Purpose","text":"<p>The purpose of this Use-Case Realization Specification is to detail the design of the \u201cView Restaurant\u201d use case, where a user selects a restaurant from the map to see further information and reviews of it.</p>"},{"location":"docs/general/UCRS_ViewRestaurant/#12-scope","title":"1.2 Scope","text":"<p>This document covers the interaction flow between the User, Front-End, Back-End, and OpenStreetMap API for filtering and displaying points of interest based on user-selected criteria.</p>"},{"location":"docs/general/UCRS_ViewRestaurant/#13-definitions-acronyms-and-abbreviations","title":"1.3 Definitions, Acronyms, and Abbreviations","text":"<ul> <li>POI: Point of Interest</li> <li>API: Application Programming Interface</li> <li>n/a: not applicable</li> <li>UCRS : Use-Case-Realization Specification</li> </ul>"},{"location":"docs/general/UCRS_ViewRestaurant/#14-references","title":"1.4 References","text":"<p>n/a</p>"},{"location":"docs/general/UCRS_ViewRestaurant/#15-overview","title":"1.5 Overview","text":"<p>This document is organized into sections detailing the purpose, scope, and flow of events in this use case, followed by derived requirements for implementation.</p>"},{"location":"docs/general/UCRS_ViewRestaurant/#2-flow-of-eventsdesign","title":"2. Flow of Events\u2014Design","text":"<p>The following describes the flow of events in the \"View Restaurant\" use case. The sequence diagram is shown below for visual reference:</p> <p></p> <p>Flow Steps: - User Action: The user clicks on a POI on the Map - Front-End Request: The front-end sends a \"get restaurant info\" request to the back end, including the id of the selected POI. - Back-End to OpenStreetMap API: The back end processes the request and sends a \"request Restaurant info\" request to the OpenStreetMap API. This request includes the id of the selected POI. To load the reviews the backend queries the database (\"request reviews\") using the POI id as well. - API Response: The OpenStreetMap API returns all available information about the requested POI. - Back-End to Front-End: The back combines the data from the OpenStreetMap API and the Database query and sends it back to the frontend (\"display restaurant information\"). - Map Display: The frontend opens the restaurant \"card\" on the left side of the screen and displays the retrieved information.</p>"},{"location":"docs/general/UCRS_ViewRestaurant/#3-derived-requirements","title":"3. Derived Requirements","text":"<ol> <li>Amount of Data: The Backend should only return a certain amount of reviews for this action. To reload more reviews the user just scrolls down the loaded reviews and more will be loaded.</li> <li>Error Handling: If the database query or the OpenStreetMap request fails, the frontend still recieves an answer with the successfully recieved data. If both fail the backend responds with an error message.  </li> <li>Scalability: The back end must efficiently handle multiple requests to the OpenStreetMap API and database queries without performance degradation.  </li> <li>Data Accuracy: The data recieved by the frontend should be displayed accurately without formatting errors.</li> </ol>"},{"location":"docs/general/quality/","title":"Qualit\u00e4tsbericht","text":"<p>Um die Qualit\u00e4t des Codes &amp; der WebApp zu gew\u00e4hrleisten wurden die folgenden Ma\u00dfnahmen getroffen:</p> <ul> <li>Es wurde eine technische Review durchgef\u00fchrt, deren Ergebniss hier eingesehen werden k\u00f6nnen.</li> <li>Es wurde ein Code Refactoring durchgef\u00fchrt um Probleme aus der Review zu addressieren</li> <li>Es wurden Code Coverage Berichte mittles JaCoCo eingerichtet, welche manuel Clientside und beim Pushen auf den Main-Branch automatisch durchgef\u00fchrt werden. Ein Beispiel davon kann hier eingesehen werden.</li> <li>Es wurde das IntelliJ-Plugin \"MetricsReloaded\" eingef\u00fchrt mit welchem Statistiken wie Attribute Hiding Factor (AHF), Coupling Factor (CF) und Average Operation Complexity (AOC) so wie viele weitere berechnet und eingesehen werden k\u00f6nnen. Mehr Informationen dazu k\u00f6nnen hier gefunden werden.</li> </ul>"},{"location":"docs/general/sad/","title":"SAD (Software Architecture Document)","text":""},{"location":"docs/general/sad/#1-introduction","title":"1. Introduction","text":""},{"location":"docs/general/sad/#11-purpose","title":"1.1 Purpose","text":"<p>This document provides a comprehensive architectural overview of the system, using a number of different architectural views to depict different aspects of the system. It is intended to capture and convey the significant architectural decisions which have been made on the system.</p>"},{"location":"docs/general/sad/#12-scope","title":"1.2 Scope","text":"<p>This Software Architecture Document provides an architectural overview of the Green-Sprout Restaurant Search-and Review System. This Document has been generated under the input of all members participating as part of the Software Engineering project using a Software Architecture Document template.</p>"},{"location":"docs/general/sad/#13-definitions-acronyms-and-abbreviations","title":"1.3 Definitions, Acronyms and Abbreviations","text":"<p>The following Definitions, Acronyms and Abbreviations are used.:</p> <ul> <li> <p>API  Application Programming Interface</p> </li> <li> <p>CRUD  Short for \"Create, Read, Update and Delete\"</p> </li> <li> <p>JWT  Jason Web Token</p> </li> <li> <p>OSM  Open Street Map</p> </li> <li> <p>ORM  Object-Relational Mapping</p> </li> <li> <p>UML  Unified Modeling Language</p> </li> </ul>"},{"location":"docs/general/sad/#14-references","title":"1.4 References","text":"<p>Applicable references are:</p> <ul> <li> <p>All of the material contained in our Github Repositories</p> </li> <li> <p>https://github.com/green-sprout/backend</p> </li> <li> <p>https://github.com/green-sprout/frontend</p> </li> <li> <p>https://github.com/green-sprout/green-sprout</p> </li> <li> <p>https://github.com/green-sprout/docs</p> </li> </ul>"},{"location":"docs/general/sad/#2-architectural-representation","title":"2. Architectural Representation","text":"<p>This document presents the architecture as a series of views:</p> <ul> <li> <p>Process View</p> </li> <li> <p>Implementation View</p> </li> </ul> <p>The purpose of these views is to relay the structure and function of the Software in a concise manner using UML-Diagrams whenever possible.</p>"},{"location":"docs/general/sad/#3-architectural-goals-and-constraints","title":"3. Architectural Goals and Constraints","text":"<p>The software architecture follows a clear goal of combining user-friendliness and technical requirements. A focus is placed on aesthetics: a uniform, green-colored design system with consistent visual elements and interactive elements improves user-friendliness through direct feedback.</p> <p>Backwards compatibility ensures the easy provision of new versions to guarantee problem-free updates. The performance of the application is optimized by response times of less than 2 seconds, ideally less than 1 second. A Google Page Speed Score of at least 90 points ensures fast loading times.</p> <p>The modular architecture separates backend, frontend and database, which increases maintainability and simplifies future extensions. For security reasons, passwords are hashed and only stored as a hash, while JWT tokens ensure the authentication and integrity of user requests.</p> <p>This architecture ensures a reliable system with a high level of user-friendliness and flexibility.</p>"},{"location":"docs/general/sad/#6-process-view","title":"6. Process View","text":"<p> The sequence diagram shows how a user selects filter criteria via the front end, whereupon the backend retrieves the appropriate map information from the Open Street Map API. The user can select a restaurant whose details and ratings are provided by the backend. They can also write a review, which is saved in the database via the backend.</p>"},{"location":"docs/general/sad/#8-implementation-view","title":"8. Implementation View","text":""},{"location":"docs/general/sad/#komponentendiagramm-der-webanwendung","title":"Komponentendiagramm der Webanwendung","text":""},{"location":"docs/general/sad/#component-diagram-overview","title":"Component Diagram Overview","text":"<p>The component diagram illustrates the architecture of the web application and highlights the main software components and their interactions. The application consists of a frontend and a backend layer that communicate with each other, as well as with external APIs and a database.  </p>"},{"location":"docs/general/sad/#components-and-their-responsibilities","title":"Components and Their Responsibilities","text":""},{"location":"docs/general/sad/#frontend","title":"Frontend","text":"<p>The frontend includes the following components:  </p>"},{"location":"docs/general/sad/#map-view","title":"Map View","text":"<ul> <li>Displays restaurants and map data based on filters selected by the user.  </li> <li>Sends requests to the backend and the OSM integration to update map data.  </li> </ul>"},{"location":"docs/general/sad/#filters","title":"Filters","text":"<ul> <li>Allows users to select search criteria such as cuisine pr dietary preferences.  </li> <li>Sends the selected filter criteria to the backend and directly to the OSM integration to retrieve filtered data.  </li> </ul>"},{"location":"docs/general/sad/#user-management","title":"User Management","text":"<ul> <li>Handles user registration, login, and session management.  </li> <li>Communicates with the Authentication Service in the backend.  </li> </ul>"},{"location":"docs/general/sad/#review-management","title":"Review Management","text":"<ul> <li>Enables registered users to write reviews and view existing ones.  </li> <li>Submits new or updated reviews to the backend for storage.  </li> </ul>"},{"location":"docs/general/sad/#backend","title":"Backend","text":"<p>The backend includes the following components:  </p>"},{"location":"docs/general/sad/#authentication-service","title":"Authentication Service","text":"<ul> <li>Handles user authentication (login, registration).  </li> <li>Sends and verifies user information in the User Management component.  </li> </ul>"},{"location":"docs/general/sad/#user-management_1","title":"User Management","text":"<ul> <li>Manages user data.  </li> <li>Stores user data in the database via the Database Layer component.  </li> </ul>"},{"location":"docs/general/sad/#osm-integration","title":"OSM Integration","text":"<ul> <li>Communicates with the OpenStreetMap API to fetch map data and restaurant objects.  </li> <li>Processes filter criteria from the frontend and backend to provide filtered data.  </li> <li>Stores restaurant data in the local database when necessary.  </li> </ul>"},{"location":"docs/general/sad/#review-management_1","title":"Review Management","text":"<ul> <li>Handles reviews and ratings received from the frontend.  </li> <li>Stores reviews in the database via the Database Layer component.  </li> </ul>"},{"location":"docs/general/sad/#database-layer","title":"Database Layer","text":"<ul> <li>Serves as the interface to the PostgreSQL database.  </li> <li>Performs CRUD operations (Create, Read, Update, Delete) for user data, reviews, and restaurant data as needed.  </li> </ul>"},{"location":"docs/general/sad/#external-components","title":"External Components","text":""},{"location":"docs/general/sad/#postgresql-database","title":"PostgreSQL Database","text":"<ul> <li>Stores user information, reviews, and, if applicable, restaurant data fetched from the OSM API.  </li> </ul>"},{"location":"docs/general/sad/#openstreetmap-api","title":"OpenStreetMap API","text":"<ul> <li>Provides map data and restaurant information.  </li> <li>Supports filtered requests based on criteria selected by the user.  </li> </ul>"},{"location":"docs/general/sad/#key-interactions","title":"Key Interactions","text":""},{"location":"docs/general/sad/#frontend-to-backend","title":"Frontend to Backend","text":"<ul> <li>User interactions (e.g., filtering, writing reviews) are sent from the frontend to the backend for processing.  </li> <li>Authentication requests and session management are handled by the Authentication Service.  </li> </ul>"},{"location":"docs/general/sad/#backend-to-osm-api","title":"Backend to OSM API","text":"<ul> <li>The backend uses the OSM integration to fetch map data and restaurant information from the OpenStreetMap API.  </li> <li>Filtered requests are forwarded based on the criteria set by the user.  </li> </ul>"},{"location":"docs/general/sad/#backend-to-database","title":"Backend to Database","text":"<ul> <li>User data, reviews, and restaurant data are stored in the PostgreSQL database and retrieved as needed.  </li> </ul>"},{"location":"docs/general/sad/#filters-to-osm-integration","title":"Filters to OSM Integration","text":"<ul> <li>The Filters component in the frontend sends selected criteria directly to the OSM integration to generate a filtered map view.  </li> </ul>"},{"location":"docs/general/sad/#11-quality","title":"11. Quality","text":""},{"location":"docs/general/sad/#extensibility","title":"Extensibility","text":"<p>Vue.js as the front end enables modular and component-based development that can be easily scaled as the number of users and features grow.  </p> <p>The backend in Spring Boot offers a clear separation of model and controller and implements parts of the MVC approach. Services and controllers can be easily extended and exchanged.  </p> <p>By using the OpenStreetMap API in the backend, the use of this API is abstracted and easier to use for the frontend, as filters and regions have to be inserted into the URL for the request to the OpenStreetMap API in a complex manner.</p>"},{"location":"docs/general/sad/#reliability","title":"Reliability","text":"<p>Spring Boot offers solid error handling and logging functions for the early detection and handling of problems.  </p> <p>The PostgreSQL database system ensures data integrity and provides mechanisms for data recovery after failures.  </p> <p>Authentication with JWT provides standardized methods to ensure secure user sessions and minimizes vulnerabilities compared to traditional authentication methods.  </p>"},{"location":"docs/general/sad/#portability","title":"Portability","text":"<p>All components of the system are platform-independent and can be deployed on all platforms and on any infrastructure using containers.  </p>"},{"location":"docs/general/sad/#security","title":"Security","text":"<p>The use of JSON web tokens offers a robust solution for secure and reliable authentication and authorization. Security risks can be minimized by simply adjusting the lifetime of a token.  </p> <p>Accessing the OpenStreetMap API through the backend as a proxy minimizes the security risks of manipulating the request in the frontend to the OpenStreetMap API.  </p> <p>Using an ORM to map and interact with the database eliminates the risks of SQL injections and sniffing.</p>"},{"location":"docs/general/srs/","title":"SRS (Software Requirement Specification)","text":""},{"location":"docs/general/srs/#1-introduction","title":"1 Introduction","text":""},{"location":"docs/general/srs/#11-purpose","title":"1.1 Purpose","text":"<p>This Software Requirement Specification (SRS) provides a comprehensive collection of  all specifications of the \"Green Sprout\" restaurant-finder application. It outlines the  purpose, scope, and key details of the project. The SRS describes both functional and non functional requirements necessary for the development and delivery of the application.</p>"},{"location":"docs/general/srs/#12-scope","title":"1.2 Scope","text":"<p>This project will be a web-based application.  The main actors of this application include reviewers and general  visitors.  The key features planned are:</p> <ul> <li> <p>Visual Map: This map is the primary element of the user interface, displaying the  area (e.g., Karlsruhe) and a set of location markers representing the restaurants at  their respective locations.</p> </li> <li> <p>Restaurant Profiles: Each restaurant has a detailed profile that initially includes its  name, type of cuisine, overall rating, and existing reviews. </p> </li> <li> <p>Registering as a Reviewer: Users can create an account with their first name, last  name, email address and a password of choice. This is necessary to gain the ability  to publish reviews of restaurants. </p> </li> <li> <p>Adding a new Review: Each restaurant on the map will have an \"Add a Review\"  option, allowing users to write a review and provide a star rating.</p> </li> <li> <p>Filtering Restaurant Searches: Users will be able to filter restaurants based on  cuisine type and diet.</p> </li> </ul>"},{"location":"docs/general/srs/#13-definitions-acronyms-and-abbreviations","title":"1.3 Definitions, Acronyms and Abbreviations","text":"Abbreviation Explanation SRS Software Requirement Specification MVP Minimum Viable Product n/a not applicable"},{"location":"docs/general/srs/#14-references","title":"1.4 References","text":"Title Date Publishing Organization Green Sprout Blog Green Sprout Team Green Sprout GitHub Repositories Green Sprout Team"},{"location":"docs/general/srs/#15-overview","title":"1.5 Overview","text":"<p>This Software Requirements Specification (SRS) document for the \"Green Sprout\" project  outlines all the requirements necessary for the development of the restaurant-finder application.  It serves as a comprehensive guideline for the design, development, and implementation of the  application.</p> <p>The SRS document is structured to cover both functional and non-functional requirements in  detail. The document is divided into several sections:</p> <p>Section 1 introduces the project, covering its purpose, scope, and relevant definitions. It also includes references to related documents and resources.</p> <p>Section 2 provides an overall description of the product, explaining its context, user  characteristics, product features, assumptions, and constraints.</p> <p>Section 3 presents the specific requirements, both functional (such as map filtering, restaurant profiles, user registration, and reviews) and non-functional (usability, reliability, and performance). This section details each feature with pre-conditions and post-conditions where  applicable, ensuring clear expectations for both developers and testers.</p> <p>Section 4 includes supporting information and especially contact information about the team.</p>"},{"location":"docs/general/srs/#2-overall-description","title":"2. Overall Description","text":""},{"location":"docs/general/srs/#a-product-perspective","title":"a. Product perspective","text":"<p>Green Sprout is a restaurant-finder web-based application. The product is intended to serve  as a comprehensive platform for finding, reviewing, and recommending restaurants within  a specific geographic area, such as Karlsruhe. The platform allows users to register as  reviewers, browse restaurants, and filter search results by cuisine type and diet preferences.  The application aims to provide users with a rich visual interface and interactive map, helping users make informed  dining decisions based on location, ratings, and reviews.</p>"},{"location":"docs/general/srs/#b-class-diagram","title":"b. Class Diagram","text":""},{"location":"docs/general/srs/#c-use-case-diagram","title":"c. Use Case Diagram","text":""},{"location":"docs/general/srs/#d-tech-stack","title":"d. Tech-Stack","text":"Scope Technology Frontend JavaScript Framework (Vue.js) Backend Java Framework (Springboot) Database PostgreSQL Project Management Jira IDE IntelliJ, VSCode Deployment GitHub Actions Testing mainly JUnit Tests"},{"location":"docs/general/srs/#e-user-characteristics","title":"e. User characteristics","text":"<p>Reviewers: Registered users who can write reviews and rate restaurants. They are primarily food enthusiasts who want to share their  experiences. General Users: Unregistered users or casual viewers who want to browse restaurants, view  reviews, and explore the map without creating an account.</p>"},{"location":"docs/general/srs/#f-requirement-subsets","title":"f. Requirement subsets","text":"<p>Core Requirements: Features necessary for the minimum viable product (MVP) include the map, restaurants, user registration, review submission, and filtering. Additional Features: Future expansions could include the ability to create restaurant lists  and add the ability to filter also for non-restaurant businesses (e.g., bars, shops).</p>"},{"location":"docs/general/srs/#3-specific-requirements","title":"3. Specific Requirements","text":""},{"location":"docs/general/srs/#31-functionality","title":"3.1 Functionality","text":"<p>This section will explain the different use cases as seen in the Use Case diagram and their  functionality 1. Configure map filter This functionality gives the user the possibility to filter for specific keys like cuisines  and diets. Sequence Diagram:  GUI Mockup:  Activity Diagram: pre-conditions: The user opened the website and is in the initial map view and selected filters.</p> <p>post-conditions: The map displays only the restaurants that match the selected filters. Story points: 13</p> <p>2. View point of interest View point of interest shows the user information about the selected point of interest (e.g restaurant) including name, cuisine, overall rating and existing reviews. Sequence Diagram:  GUI Mockup:  Activity Diagram: pre-conditions: Clicked on restaurant marker on the map. post-conditions: Side bar with restaurant information and reviews opens. Story points: 13</p> <p>3. Write review A reviewer has the possibility to write a review for the currently selected restaurant. The review includes a rating as well as review text. Sequence Diagram:  GUI Mockup:  Activity Diagram: pre-conditions: The user is logged in and on the restaurant's profile page and clicked on \"write review\u201d button. post-conditions: Pop-up window to write review opens. Story points: 21</p>"},{"location":"docs/general/srs/#32-usability","title":"3.2 Usability","text":""},{"location":"docs/general/srs/#321-user-training-and-learning-time","title":"3.2.1 User Training and Learning Time","text":"<p>Normal Users (General Visitors and Unregistered Users): The application should be intuitive enough that a new user can browse restaurants, view details, and read reviews with minimal effort. No training should be required, and users should become proficient in basic tasks (e.g., navigating the map, searching restaurants) within a few minutes. Power Users (Registered Reviewers): Reviewers who will frequently submit reviews should become proficient in these more complex tasks after doing them once.</p>"},{"location":"docs/general/srs/#322-task-efficiency","title":"3.2.2 Task Efficiency","text":"<p>Restaurant Search and Filtering: Users should be able to filter restaurant searches by  cuisine type or diet within 5 clicks or taps. The results should update in under 3 seconds on average. Review Submission: Registered users must be able to submit a new review with a star  rating in under 1 minute, assuming an average internet connection.</p>"},{"location":"docs/general/srs/#323-user-interface-ui-standards","title":"3.2.3 User Interface (UI) Standards","text":"<p>The UI should adhere to modern usability standards for web applications, such as providing a consistent layout across all pages, and easy-to-read fonts. Interactive elements (buttons, forms, filters) should be clearly distinguishable with appropriate spacing and color contrast.</p>"},{"location":"docs/general/srs/#324-error-handling-and-feedback","title":"3.2.4 Error Handling and Feedback","text":"<p>Users must receive clear and concise feedback when an error occurs (e.g., invalid form  inputs, failed review submission). The system should provide confirmations for critical actions such as submitting reviews  or creating new restaurant lists.</p>"},{"location":"docs/general/srs/#33-usability","title":"3.3 Usability","text":""},{"location":"docs/general/srs/#331-availability","title":"3.3.1 Availability","text":"<p>The system must be available 97% of the time. Scheduled maintenance windows should be communicated to users in advance.</p>"},{"location":"docs/general/srs/#332-fault-tolerance","title":"3.3.2 Fault Tolerance","text":"<p>The system must be capable of handling unexpected failures in the database, server, or network without causing a complete system shutdown.</p>"},{"location":"docs/general/srs/#333-data-integrity","title":"3.3.3 Data Integrity","text":"<p>The system must ensure that user reviews, restaurant profiles, and other critical data are stored safely, even in the event of hardware failure, power outages, or software crashes. Transaction management and database operations must follow ACID (Atomicity, Consistency, Isolation, Durability) principles to guarantee data integrity.</p>"},{"location":"docs/general/srs/#34-performance","title":"3.4 Performance","text":""},{"location":"docs/general/srs/#341-response-time","title":"3.4.1 Response Time","text":"<p>The system must provide a response time of less than 3 seconds for all major user actions under normal conditions, including: - Searching for restaurants - Viewing restaurant profiles - Submitting reviews and ratings In high load conditions, the response time should not exceed 5 seconds.  </p>"},{"location":"docs/general/srs/#342-database-performance","title":"3.4.2 Database Performance","text":"<p>Queries to the database (e.g., fetching restaurant details, reviews or ratings) must return results within 2 seconds under normal load and no more than 5 seconds under peak load. Bulk operations, such as batch importing of restaurant data, should complete within 15 minutes.</p>"},{"location":"docs/general/srs/#35-supportability","title":"3.5 Supportability","text":""},{"location":"docs/general/srs/#351-coding-standards","title":"3.5.1 Coding Standards","text":"<p>The Green Sprout project will adhere to clean code principles and industry best practices, ensuring modular, maintainable, and scalable code. All code will follow standard naming conventions, proper indentation, and include sufficient comments to enhance readability and ease future development. Version control (Git) will be used to manage code changes, ensuring traceability and allowing for safe rollbacks when necessary.</p>"},{"location":"docs/general/srs/#352-testing-strategy","title":"3.5.2 Testing Strategy","text":"<p>A comprehensive testing strategy will be implemented, including automated unit tests.  </p>"},{"location":"docs/general/srs/#36-design-constraints","title":"3.6 Design Constraints","text":"<p>Technology Stack: The application will be built using Vue.js for the frontend, Spring Boot with Java for the backend, and PostgreSQL as the database. These technologies define the framework and limit the design to what is supported by these tools.  </p> <p>Responsiveness: The user interface must be designed to work seamlessly across various desktop devices, adhering to responsive design principles.  </p> <p>Data Storage: The application will store user and restaurant data in a relational database (PostgreSQL), which constrains the design to a schema that ensures efficient querying and data integrity.  </p> <p>Security: All design elements must consider security measures like encrypted  communication (HTTPS), authentication, and secure database access to protect user data and maintain privacy.</p>"},{"location":"docs/general/srs/#37-on-line-user-documentation-and-help-system-requirements","title":"3.7 On-line User Documentation and Help System Requirements","text":"<p>The usage of the web application should be as intuitive as possible so it won't need any further documentation. If the user needs some help they should be able to contact the development team.</p>"},{"location":"docs/general/srs/#38-purchased-components","title":"3.8 Purchased Components","text":"<p>We don't have any purchased components yet. If there will be purchased components in the future we will list them here.</p>"},{"location":"docs/general/srs/#39-interfaces","title":"3.9 Interfaces","text":"<p>The user interfaces to be implemented are:</p> <ul> <li>Home Page \u2013 Displays a map with restaurant markers, search options, and featured restaurants.</li> <li>Restaurant Profile Page \u2013 Shows detailed information about a restaurant, including reviews, ratings, and location.</li> <li>Login Page \u2013 Allows users to log into the platform.</li> <li>Register Page \u2013 Provides a registration form for new users to sign up.</li> <li>Review Submission Page \u2013 Allows users to submit reviews and ratings for restaurants.</li> </ul>"},{"location":"docs/general/srs/#391-hardware-interfaces","title":"3.9.1 Hardware Interfaces","text":"<p>n/a</p>"},{"location":"docs/general/srs/#392-software-interfaces","title":"3.9.2 Software Interfaces","text":"<p>This application will be runnable on desktop browsers (Chrome, Edge, Safari, Firefox, etc.).</p>"},{"location":"docs/general/srs/#393-communications-interfaces","title":"3.9.3 Communications Interfaces","text":"<p>The server and browser will communicate using https protocol.</p>"},{"location":"docs/general/srs/#310-architecturally-significant-requirements","title":"3.10 Architecturally Significant Requirements","text":"Quality attribute Refinement Quality attribute scenarios Business value Technical risk Aesthetics Design The design is centered around meeting user needs with a cohesive, green-themed design system. Visual elements are consistently styled to ensure a unified look and feel across the interface. Interactive elements, such as buttons, provide immediate feedback for example color change, giving users a clear confirmation of their actions and enhancing the overall user experience. H L Conformance Ease of Deployment Deploying a new version of a component should be made simple by providing sufficient resources to the deployer. The new component must be backward compatible to ensure stable conversion to newer program versions. M L Performance Response Time The application, especially in terms of communication with the backend and API, should maintain a response time under 2 seconds. Ideally, it should stay within the 1-second range to ensure a seamless user experience. H M Page Speed A user, no matter what device, should see a visually appealing and fast page. A google page speed insight analysis of at least 90 points is considered to be good H L Serviceability Modularity Backend, Frontend &amp; Database should be seperated at any given time. Sections should be kept structured to allow adding further Feature-Modules at a later point. M M Security User-Data-Encryption By hashing the password of a user immediately after recieving it in the backend, and only storing this hash guarantees the security of the password. The authentication of all user requests and their integrity is verified by using industry-standard JWT tokens. H H"},{"location":"docs/general/srs/#311-licensing-requirements","title":"3.11 Licensing Requirements","text":"<p>n/a</p>"},{"location":"docs/general/srs/#312-legal-copyright-and-other-notices","title":"3.12 Legal, Copyright, and Other Notices","text":"<p>We do not take responsibility for any incorrect data or errors in the application.</p>"},{"location":"docs/general/srs/#313-applicable-standards","title":"3.13 Applicable Standards","text":"<p>The development will follow the common clean code standards and naming conventions (see section 3.5.1 Coding standards).</p>"},{"location":"docs/general/srs/#4-supporting-information","title":"4. Supporting Information","text":"<p>For any further information you can contact the Green Sprout Team or check our Green Sprout Blog The Team Members are: - Paula Kropfinger - Valentin W\u00f6hrle - Jonas Schl\u00f6sser - Samuel Brekeller - Safae Kartite</p>"},{"location":"docs/general/testPlan/","title":"Test plan","text":"<ul> <li>Test plan<ul> <li>1. Introduction<ul> <li>1.1 Purpose</li> <li>1.2 Scope</li> <li>1.3 Intended Audience</li> <li>1.4 Document Terminology and Acronyms</li> <li>1.5  References</li> </ul> </li> <li>2. Evaluation Mission and Test Motivation<ul> <li>2.1 Background</li> <li>2.2 Evaluation Mission</li> <li>2.3 Test Motivators</li> </ul> </li> <li>3. Target Test Items</li> <li>4. Outline of Planned Tests<ul> <li>4.1 Outline of Test Inclusions</li> <li>4.2 Outline of Other Candidates for Potential Inclusion</li> <li>4.3 Outline of Test Exclusions</li> </ul> </li> <li>5. Test Approach<ul> <li>5.1 Testing Techniques and Types<ul> <li>5.1.1 Unit Testing</li> <li>5.1.2 Integration Testing (API Testing)</li> </ul> </li> </ul> </li> <li>6. Entry and Exit Criteria<ul> <li>6.1 Test Plan<ul> <li>6.1.1 Test Plan Entry Criteria</li> <li>6.1.2 Test Plan Exit Criteria</li> </ul> </li> </ul> </li> <li>7. Deliverables<ul> <li>7.1 Test Evaluation Summaries</li> <li>7.2 Reporting on Test Coverage</li> <li>7.3 Perceived Quality Reports</li> <li>7.4 Incident Logs and Change Requests</li> <li>7.5 Smoke Test Suite and Supporting Test Scripts</li> </ul> </li> <li>8. Testing Workflow</li> <li>9. Environmental Needs<ul> <li>9.1 Base System Hardware</li> <li>9.2 Base Software Elements in the Test Environment</li> <li>9.3 Productivity and Support Tools</li> </ul> </li> <li>10. Responsibilities, Staffing, and Training Needs<ul> <li>10.1 People and Roles</li> <li>10.2 Staffing and Training Needs</li> </ul> </li> <li>11. Iteration Milestones</li> <li>12. Risks, Dependencies, Assumptions, and Constraints</li> <li>13. Management Process and Procedures</li> </ul> </li> </ul>"},{"location":"docs/general/testPlan/#1-introduction","title":"1. Introduction","text":""},{"location":"docs/general/testPlan/#11-purpose","title":"1.1 Purpose","text":"<p>The purpose of the Iteration Test Plan is to gather all of the information necessary to plan and control the test effort for a given iteration. It describes the approach to testing the software. This Test Plan for Green Sprout supports the following objectives:</p> <ul> <li>Identifies the issues to be addressed by the tests.</li> <li>Identifies the motivation and ideas behind the test areas to be covered.</li> <li>Outlines the testing approach to be used.</li> <li>Identifies the resources required and provides an estimate of the testing effort.</li> </ul>"},{"location":"docs/general/testPlan/#12-scope","title":"1.2 Scope","text":"<p>This test plan outlines the tests designed to verify the functionality of the front-end and back-end of the application and the interaction between them.</p> <p>The document includes the following types of testing:</p> <ul> <li>Unit testing</li> <li>Integration testing</li> <li>Data Consistency Tests</li> <li>API testing</li> </ul> <p>Excluded from this plan are tests related to performance, user interface, scalability and usability.</p>"},{"location":"docs/general/testPlan/#13-intended-audience","title":"1.3 Intended Audience","text":"<p>This test plan is written primarily for internal documentation purposes. It serves as a guideline for developers and as documentation for measuring compliance with quality requirements.</p>"},{"location":"docs/general/testPlan/#14-document-terminology-and-acronyms","title":"1.4 Document Terminology and Acronyms","text":"Abbr Abbreviation API Application Programmable Interface n/a not applicable SRS Software Requirements Specification"},{"location":"docs/general/testPlan/#15-references","title":"1.5  References","text":"Title Date Publishing organization SRS unknown Green Sprout"},{"location":"docs/general/testPlan/#2-evaluation-mission-and-test-motivation","title":"2. Evaluation Mission and Test Motivation","text":""},{"location":"docs/general/testPlan/#21-background","title":"2.1 Background","text":"<p>The primary reason for the testing effort outlined in this test plan is to validate the integration of the various components of the web-based restaurant discovery platform. Since the system relies on interactions between a dynamic front-end, a data-driven back-end, and third-party services such as map APIs, integration testing is essential to ensure that these components work together reliably.</p> <p>Without proper integration testing, issues may arise that are not visible in isolated unit tests, but could significantly impact the user experience.</p> <p>This testing phase will help identify interface mismatches and data inconsistencies across the system. A full description of the system architecture and features can be found in the SRS document.</p>"},{"location":"docs/general/testPlan/#22-evaluation-mission","title":"2.2 Evaluation Mission","text":"<p>The purpose is to verify that all integrated components of the application work together as intended, and meet the requirements defined in the SRS. This ensures a seamless and reliable user experience across all key functions.</p>"},{"location":"docs/general/testPlan/#23-test-motivators","title":"2.3 Test Motivators","text":"<p>The motivation for unit testing is to ensure that individual components function correctly in isolation, while integration testing validates the seamless interaction of these components within the overall system. Both are critical to ensuring reliability and robustness before release.</p>"},{"location":"docs/general/testPlan/#3-target-test-items","title":"3. Target Test Items","text":"<ul> <li>Server backend (and APIs)</li> <li>Database Interaction</li> </ul>"},{"location":"docs/general/testPlan/#4-outline-of-planned-tests","title":"4. Outline of Planned Tests","text":""},{"location":"docs/general/testPlan/#41-outline-of-test-inclusions","title":"4.1 Outline of Test Inclusions","text":"<p>Backend: Spring Boot Application:</p> <ul> <li>Unit testing</li> <li>Integration testing</li> <li>Api testing</li> </ul> <p>Database (PostgreSQL)</p> <ul> <li>Integration Tests</li> <li>Data Consistency Tests</li> </ul>"},{"location":"docs/general/testPlan/#42-outline-of-other-candidates-for-potential-inclusion","title":"4.2 Outline of Other Candidates for Potential Inclusion","text":"<p>n/a</p>"},{"location":"docs/general/testPlan/#43-outline-of-test-exclusions","title":"4.3 Outline of Test Exclusions","text":"<p>Because of time and resource constraints we will not do:</p> <ul> <li>Stress test</li> <li>Load/performance tests</li> <li>Usability tests</li> <li>any further tests</li> </ul>"},{"location":"docs/general/testPlan/#5-test-approach","title":"5. Test Approach","text":""},{"location":"docs/general/testPlan/#51-testing-techniques-and-types","title":"5.1 Testing Techniques and Types","text":""},{"location":"docs/general/testPlan/#511-unit-testing","title":"5.1.1 Unit Testing","text":"<p>Unit testing ensures, that the tested sourcecode works as expected. Therefore small parts of the sourcecode are tested independently.</p> Description Technique Objective Ensure that the implemented code works as expected Technique Implement test methods using the JUnit 5 Framework (Backend) Oracles Test execution logs results to the command line, logging manually ( for now, to be changed) Required Tools JUnit 5 dependencies in our Backend Success Criteria All tests pass. Coverage is above 66% (2/3, Backend) CI/CD Pipeline: Github Actions Special Considerations -"},{"location":"docs/general/testPlan/#512-integration-testing-api-testing","title":"5.1.2 Integration Testing (API Testing)","text":"<p>Api Testing is part of integration testing. Integration tests test multiple modules of an application together. The main goal of Api testing is to ensure, that the provided Apis of the Backend behave as expected.</p> Description Technique Objective Test API-Requests Technique Usage of Mock-API-Requests Oracles Test execution logs results to the command line, logging manually ( for now, to be changed) Required Tools JUnit Success Criteria All tests pass. Coverage is above 66% (2/3) CI/CD Pipeline: Github Actions Special Considerations -"},{"location":"docs/general/testPlan/#6-entry-and-exit-criteria","title":"6. Entry and Exit Criteria","text":""},{"location":"docs/general/testPlan/#61-test-plan","title":"6.1 Test Plan","text":""},{"location":"docs/general/testPlan/#611-test-plan-entry-criteria","title":"6.1.1 Test Plan Entry Criteria","text":"<p>n/a</p>"},{"location":"docs/general/testPlan/#612-test-plan-exit-criteria","title":"6.1.2 Test Plan Exit Criteria","text":"<p>n/a</p>"},{"location":"docs/general/testPlan/#7-deliverables","title":"7. Deliverables","text":""},{"location":"docs/general/testPlan/#71-test-evaluation-summaries","title":"7.1 Test Evaluation Summaries","text":"<p>The current version of the project includes only backend testing, more specifically JUnit 5 tests with mocking for the Spring boot backend classes. The final version of the project is so planned, so that integration tests are also implemented and the automation is realised through the implementation of CI/CD Pipelines. These would eventually be responsible for the evaluation of the tests, which would take place every time changes are pushed into the  code repository, GitHub Actions being the chosen platform for the workflow.</p> <p>At this point of the project Unit tests can be manually and locally evaluated through either starting the tests from the IDE oder executing the following command: <code>mvn test</code></p> <p>As shown in the screenshot below, the IDE specifies the number of passed tests as well as gives logs and where applicable warnings/error messages.  The content of the currently implemented test classes, for example the OsmControllerTest Class, can be explained as followed: </p> <p>The OsmControllerTest class is a unit test designed to validate the functionality of the OsmController class, specifically its getNodes method. It uses Mockito to mock the OsmService dependency, allowing for controlled testing of the controller's behavior without relying on the actual service implementation. The test class includes two test cases: one that verifies a successful response when valid parameters (an amenity type and a list of coordinates) are provided, ensuring that the response status is 200 and the body contains the expected JSON data; and another that checks the handling of invalid coordinates, asserting that the response status is 400 and the body contains an appropriate error message. The setup method initializes the mocks before each test is executed.</p> <p></p>"},{"location":"docs/general/testPlan/#72-reporting-on-test-coverage","title":"7.2 Reporting on Test Coverage","text":"<p>For reporting our test coverage, we currently rely on manual test reports.</p>"},{"location":"docs/general/testPlan/#73-perceived-quality-reports","title":"7.3 Perceived Quality Reports","text":"<p>Perceived quality reports for the GreenSprout application will focus on the results of the JUnit tests and integration tests conducted during the development process. If any reports are generated (when applicable), they will be generated manually, providing the development team with a clear overview of the application's quality and stability. The analysis will include a review of incidents related to test failures and any associated change requests, ensuring that the team can address quality concerns effectively.</p>"},{"location":"docs/general/testPlan/#74-incident-logs-and-change-requests","title":"7.4 Incident Logs and Change Requests","text":"<p>Any noticed errors during the execution of tests either locally or through triggering the CI/CD Pipeline will be immediately reported to team members, and fixing the mistakes will be added as a ticket for the following sprint.</p>"},{"location":"docs/general/testPlan/#75-smoke-test-suite-and-supporting-test-scripts","title":"7.5 Smoke Test Suite and Supporting Test Scripts","text":"<p>The smoke test suite for the GreenSprout application will consist of a set of automated tests designed to verify the core functionalities of the application's backend. Supporting test scripts will be developed using JUnit and Mockito for unit testing, along with integration tests to ensure that different components of the application work together seamlessly. The smoke test suite will be executed as part of the CI/CD pipeline using GitHub Actions, allowing for immediate feedback on the stability of new builds and helping to detect regressions in product quality early in the development process.</p>"},{"location":"docs/general/testPlan/#8-testing-workflow","title":"8. Testing Workflow","text":"<p>Currently, the Test-Workflow is as follows.: 1) Local testing in the IDE before a commit - Results are manually logged</p> <p>Ideally, the Test-Workflow will eventually take the following form or be similar to it.: 1) Local testing in the IDE 2) Commit and Push triggers build and test execption in the CI/CD Pipeline 3) Each PR triggers the pipeline (build and test) 4) Before the automated deployment the build and test stages are executed</p>"},{"location":"docs/general/testPlan/#9-environmental-needs","title":"9. Environmental Needs","text":""},{"location":"docs/general/testPlan/#91-base-system-hardware","title":"9.1 Base System Hardware","text":"<p>The following table sets forth the system resources for the test effort presented in this Test Plan.</p> Resource Quantity Name and Type CI/CD server 1 Github Actions local test machine 1 notebook (Jonas,Safae,Samuel,Paula,Valentin) Android test device 1 Android device (Jonas,Safae,Samuel,Paula,Valentin)"},{"location":"docs/general/testPlan/#92-base-software-elements-in-the-test-environment","title":"9.2 Base Software Elements in the Test Environment","text":"<p>The following base software elements are required in the test environment for this Test Plan.</p> Software Element Name Type and Other Notes IntelliJ Test Runner / IDE JUnit  5 Unit testing library"},{"location":"docs/general/testPlan/#93-productivity-and-support-tools","title":"9.3 Productivity and Support Tools","text":"<p>The following tools will be employed to support the test process for this Test Plan.</p> Tool Category or Type Tool Brand Name Repository github.com CI/CD Service Github Actions"},{"location":"docs/general/testPlan/#10-responsibilities-staffing-and-training-needs","title":"10. Responsibilities, Staffing, and Training Needs","text":""},{"location":"docs/general/testPlan/#101-people-and-roles","title":"10.1 People and Roles","text":"Role Person Assigned Specific Responsibilities or Comments Test Manager Safae, Jonas Provides management oversight. Test Designer Safae, Paula Defines the technical approach to the implementation of the test effort. Test System Administrator Valentin, Samuel Ensures test environment and assets are managed and maintained."},{"location":"docs/general/testPlan/#102-staffing-and-training-needs","title":"10.2 Staffing and Training Needs","text":"<p>n/a</p>"},{"location":"docs/general/testPlan/#11-iteration-milestones","title":"11. Iteration Milestones","text":"<p>We want to keep over 66% code coverage.</p>"},{"location":"docs/general/testPlan/#12-risks-dependencies-assumptions-and-constraints","title":"12. Risks, Dependencies, Assumptions, and Constraints","text":"Risk Mitigation Strategy Contingency (Risk is realized) Code has lots of side effects Refactor code (Clean Code principles) publish new refactored tests Test Runner is not able to execute tests Use standard libraries which include working Test Runner fix test execution configuration UI tests fail Refactor test publish refactored test and restart"},{"location":"docs/general/testPlan/#13-management-process-and-procedures","title":"13. Management Process and Procedures","text":"<p>n/a</p>"},{"location":"docs/sprintmeetings/sprint2/","title":"Sprintmeeting 2","text":"<p>Sprint 22.10.2024 bis 05.11.2024 </p>"}]}